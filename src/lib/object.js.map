{"version":3,"file":"object.js","sources":["../src/$core$/Keys.ts","../src/$core$/AssignObject.ts","../src/$core$/ReactiveLib.ts","../src/$core$/Time.ts"],"sourcesContent":["export const $extractKey$ = \"$@extract@$\";//Symbol(\"@extract\");\r\nexport const $originalKey$ = \"$@origin@$\";//Symbol(\"@origin\");\r\nexport const $originalObjects$ = new WeakMap();\r\n\r\n//\r\nexport const boundCtx = new WeakMap();\r\nexport const bindFx = (target, fx)=>{\r\n    if (!boundCtx.has(target)) {\r\n        boundCtx.set(target, new WeakMap());\r\n    }\r\n\r\n    //\r\n    const be = boundCtx.get(target);\r\n    if (!be.has(fx)) {\r\n        const bfx = fx?.bind?.(target);\r\n        be.set(fx, bfx);\r\n    }\r\n\r\n    //\r\n    return be.get(fx);\r\n}\r\n\r\n//\r\nexport const bindCtx = (target, fx) => {\r\n    return (typeof fx == \"function\" ? bindFx(target, fx) : fx) ?? fx;\r\n}\r\n\r\n//\r\nexport type keyType = string | number | symbol;\r\n\r\n// TODO! WeakMap or WeakSet support\r\nexport const isKeyType = (prop: any)=>{\r\n    return [\"symbol\", \"string\", \"number\"].indexOf(typeof prop) >= 0;\r\n}\r\n\r\n//\r\nexport const isIterable = (obj) => {\r\n    return (typeof obj?.[Symbol.iterator] == \"function\");\r\n}\r\n\r\n//\r\nexport const callByProp = (unwrap, prop, cb, ctx)=>{\r\n    if (unwrap instanceof Map || unwrap instanceof WeakMap) {\r\n        if (prop != null && unwrap.has(prop as any)) {\r\n            return cb?.(unwrap.get(prop as any), prop);\r\n        }\r\n    } else\r\n\r\n    //\r\n    if (unwrap instanceof Set || unwrap instanceof WeakSet) {\r\n        if (prop != null && unwrap.has(prop as any)) {\r\n            // @ts-ignore\r\n            return cb?.(prop, prop);\r\n        }\r\n    } else\r\n\r\n    //\r\n    if (typeof unwrap == \"function\" || typeof unwrap == \"object\") {\r\n        return cb?.(Reflect.get(unwrap, prop, ctx ?? unwrap), prop);\r\n    }\r\n}\r\n\r\n//\r\nexport const callByAllProp = (unwrap, cb, ctx)=>{\r\n    let keys: any = [];\r\n    if (unwrap instanceof Set || unwrap instanceof Map || Array.isArray(unwrap) || isIterable(unwrap) || typeof unwrap?.keys == \"function\") {\r\n        // @ts-ignore\r\n        keys = unwrap?.keys?.() || [];\r\n    } else\r\n    if ((typeof unwrap == \"object\" || typeof unwrap == \"function\") && unwrap != null) {\r\n        keys = Object.keys(unwrap) || [];\r\n    }\r\n    return keys != null ? Array.from(keys)?.map?.((prop)=>callByProp(unwrap, prop, cb, ctx)) : [];\r\n}\r\n\r\n//\r\nexport const safe = (target)=>{\r\n    const unwrap: any = (typeof target == \"object\" || typeof target == \"function\") ? (target?.[$extractKey$] ?? target) : target;\r\n    const mapped = (e)=>safe(e);\r\n\r\n    //\r\n    if (Array.isArray(unwrap)) {\r\n        return unwrap?.map?.(mapped) || Array.from(unwrap || [])?.map?.(mapped) || [];\r\n    } else\r\n\r\n    //\r\n    if (unwrap instanceof Map || unwrap instanceof WeakMap) {\r\n        // @ts-ignore\r\n        return new Map(Array.from(unwrap?.entries?.() || [])?.map?.(([K,V])=>[K,safe(V)]));\r\n    } else\r\n\r\n    //\r\n    if (unwrap instanceof Set || unwrap instanceof WeakSet) {\r\n        // @ts-ignore\r\n        return new Set(Array.from(unwrap?.values?.() || [])?.map?.(mapped));\r\n    } else\r\n\r\n    //\r\n    if (unwrap != null && typeof unwrap == \"function\" || typeof unwrap == \"object\") {\r\n        return Object.fromEntries(Array.from(Object.entries(unwrap || {}) || [])?.filter?.(([K])=>(K != $extractKey$ && K != $originalKey$))?.map?.(([K,V])=>[K,safe(V)]));\r\n    }\r\n\r\n    //\r\n    return unwrap;\r\n}\r\n","import { $extractKey$, $originalKey$, $originalObjects$, isIterable, type keyType } from \"./Keys.js\";\r\n\r\n//\r\nexport const removeExtra = (target, value, name: keyType | null = null)=>{\r\n    const exists = name != null && (typeof target == \"object\" || typeof target == \"function\") ? (target?.[name] ?? target) : target;\r\n\r\n    //\r\n    let entries: any = [];\r\n    if (value instanceof Set || value instanceof Map || Array.isArray(value) || isIterable(value)) {\r\n        entries = ((exists instanceof Set || exists instanceof WeakSet) ? value?.values?.() : value?.entries?.()) || ((Array.isArray(value) || isIterable(value)) ? value : []);\r\n    } else\r\n    if (typeof value == \"object\" || typeof value == \"function\") {\r\n        entries = (exists instanceof Set || exists instanceof WeakSet) ? Object.values(value) : Object.entries(value);\r\n    }\r\n\r\n    //\r\n    let exEntries: any = [];\r\n    if (Array.isArray(exists)) {\r\n        exEntries = exists.entries();\r\n    } else\r\n    if (exists instanceof Map || exists instanceof WeakMap) {\r\n        // @ts-ignore\r\n        exEntries = exists?.entries?.();\r\n    } else\r\n    if (exists instanceof Set || exists instanceof WeakSet) {\r\n        // @ts-ignore\r\n        exEntries = exists?.values?.();\r\n    } else\r\n    if (typeof exists == \"object\" || typeof exists == \"function\") {\r\n        exEntries = Object.entries(exists);\r\n    }\r\n\r\n    // REQUIRES NEW ECMASCRIPT!!!\r\n    const keys = new Set(Array.from(entries).map((e)=>e?.[0]));\r\n    const exe  = new Set(Array.from(exEntries).map((e)=>e?.[0]));\r\n    const exclude = keys?.difference?.(exe);\r\n\r\n    //\r\n    if (Array.isArray(exists)) {\r\n        const nw = exists.filter((_,I)=>!exclude.has(I));\r\n        exists.splice(0, exists.length);\r\n        exists.push(...nw);\r\n    } else\r\n    if (exists instanceof Map || exists instanceof WeakMap) {\r\n        for (const k of exclude) { exists.delete(k); };\r\n    } else\r\n    if (exists instanceof Set || exists instanceof WeakSet) {\r\n        for (const k of exclude) { exists.delete(k); };\r\n    } else\r\n    if (typeof exists == \"function\" || typeof exists == \"object\") {\r\n        for (const k of exclude) { delete exists[k]; };\r\n    }\r\n\r\n    //\r\n    return exists;\r\n}\r\n\r\n//\r\nexport const mergeByKey = (items: any[]|Set<any>, key = \"id\")=>{\r\n    const entries = Array.from(items?.values?.()).map((I)=>[I?.[key],I]);\r\n    const map = new Map(entries as any);\r\n    return Array.from(map?.values?.() || []);\r\n}\r\n\r\n//\r\nexport const objectAssign = (target, value, name: keyType | null = null, removeNotExists = true, mergeKey = \"id\")=>{\r\n    const exists = name != null && (typeof target == \"object\" || typeof target == \"function\") ? (target?.[name] ?? target) : target;\r\n    let entries: any = [];\r\n\r\n    //\r\n    if (removeNotExists) { removeExtra(exists, value); }\r\n\r\n    //\r\n    if (value instanceof Set || value instanceof Map || Array.isArray(value) || isIterable(value)) {\r\n        entries = ((exists instanceof Set || exists instanceof WeakSet) ? value?.values?.() : value?.entries?.()) || ((Array.isArray(value) || isIterable(value)) ? value : []);\r\n    } else\r\n    if (typeof value == \"object\" || typeof value == \"function\") {\r\n        entries = (exists instanceof Set || exists instanceof WeakSet) ? Object.values(value) : Object.entries(value);\r\n    }\r\n\r\n    //\r\n    if (exists && entries && (typeof entries == \"object\" || typeof entries == \"function\")) {\r\n        if (exists instanceof Map || exists instanceof WeakMap) {\r\n            for (const E of entries) {\r\n                // @ts-ignore\r\n                exists.set(...E);\r\n            }\r\n            return exists;\r\n        }\r\n\r\n        //\r\n        if (exists instanceof Set || exists instanceof WeakSet) {\r\n            for (const E of entries) {\r\n                // @ts-ignore\r\n                const mergeObj = E?.[mergeKey] ? Array.from(exists?.values?.() || []).find((I)=>I?.[mergeKey]==E?.[mergeKey]) : null;\r\n                if (mergeObj) { objectAssign(mergeObj, E, null, removeNotExists, mergeKey); } else { exists.add(E); }\r\n            }\r\n            return exists;\r\n        }\r\n\r\n        //\r\n        if (typeof exists == \"object\" || typeof exists == \"function\") {\r\n            if (Array.isArray(exists) || isIterable(exists)) {\r\n                let I = 0;\r\n                for (const E of entries) {\r\n                    if (I < exists.length) { exists[I++] = E?.[1]; } else { exists?.push?.(E?.[1]); };\r\n                }\r\n                return exists;\r\n            }\r\n            return Object.assign(exists, Object.fromEntries([...(entries||[])]));\r\n        }\r\n    }\r\n\r\n    //\r\n    if (name != null) {\r\n        Reflect.set(target, name, value);\r\n        return target;\r\n    } else\r\n    if (typeof value == \"object\" || typeof value == \"function\") {\r\n        return Object.assign(target, value);\r\n    }\r\n\r\n    //\r\n    return value;\r\n}\r\n\r\n//\r\nexport class AssignObjectHandler {\r\n    //\r\n    constructor() {\r\n    }\r\n\r\n    //\r\n    get(target, name: keyType, ctx) {\r\n        if (name == $extractKey$ || name == $originalKey$) {\r\n            return target?.[name] ?? target;\r\n        }\r\n        return Reflect.get(target, name, ctx);\r\n    }\r\n\r\n    //\r\n    construct(target, args, newT) {\r\n        return Reflect.construct(target, args, newT);\r\n    }\r\n\r\n    //\r\n    has(target, prop: keyType) {\r\n        return Reflect.has(target, prop);\r\n    }\r\n\r\n    //\r\n    apply(target, ctx, args) {\r\n        return Reflect.apply(target, ctx, args);\r\n    }\r\n\r\n    //\r\n    set(target, name: keyType, value) {\r\n        objectAssign(target, value, name);\r\n        return true;\r\n    }\r\n\r\n    //\r\n    deleteProperty(target, name: keyType) {\r\n        const result = Reflect.deleteProperty(target, name);\r\n        return result;\r\n    }\r\n}\r\n\r\n//\r\nexport const makeObjectAssignable = (obj) => {\r\n    // @ts-ignore\r\n    const px = new Proxy(obj, new AssignObjectHandler());\r\n    $originalObjects$.set(px, obj);\r\n    return px;\r\n};\r\n\r\n//\r\n//export { $originalKey$ };\r\n","import { objectAssign } from \"./AssignObject\";\r\nimport { $originalObjects$, $originalKey$, $extractKey$, type keyType, bindCtx, isKeyType, isIterable, callByProp, callByAllProp, safe } from \"./Keys.js\";\r\n\r\n//\r\nexport { safe };\r\n\r\n//\r\nexport class Subscript {\r\n    subscribers: Map<keyType, Set<(value: any, prop: keyType) => void>>;\r\n    listeners: Set<(value: any, prop: keyType) => void>;\r\n\r\n    //\r\n    constructor(){\r\n        this.subscribers = new Map();\r\n        this.listeners = new Set();\r\n    }\r\n\r\n    //\r\n    subscribe(cb: (value: any, prop: keyType) => void, prop: keyType | null) {\r\n        if (prop != null) {\r\n            if (this.subscribers.has(prop)) {\r\n                this.subscribers.get(prop)?.add?.(cb);\r\n            } else {\r\n                this.subscribers.set(prop, new Set([cb]));\r\n            }\r\n        } else\r\n        if (!this.listeners.has(cb)) {\r\n            this.listeners.add?.(cb);\r\n        }\r\n    }\r\n\r\n    //\r\n    trigger(name, value = null, oldValue?: any) {\r\n        Array.from(this.subscribers.get(name)?.values?.() || []).forEach((cb: (value: any, prop: keyType, oldValue?: any) => void) => cb(value, name, oldValue));\r\n        Array.from(this.listeners?.values?.() || []).forEach((cb: (value: any, prop: keyType, oldValue?: any) => void) => cb(value, name, oldValue));\r\n    }\r\n}\r\n\r\n//\r\nconst subscriptRegistry = new WeakMap<any, Subscript>();\r\nconst register = (what: any, handle: any): any => {\r\n    const unwrap = what?.[$extractKey$] ?? what;\r\n    if (!subscriptRegistry.has(unwrap)) {\r\n        subscriptRegistry.set(unwrap, new Subscript());\r\n    }\r\n    return handle;\r\n}\r\n\r\n//\r\nexport const bindByKey = (target, reactive, key = ()=>\"\")=>{\r\n    subscribe(reactive, (value, id)=>{\r\n        if (id == key()) { objectAssign(target, value, null, true); }\r\n    });\r\n}\r\n\r\n//\r\nexport const bindWith = (target, reactive, watch?) => {\r\n    subscribe(reactive, (v,p)=>{ objectAssign(target, v, p, true); });\r\n    watch?.(() => target, (N) => { for (const k in N) { objectAssign(reactive, N[k], k, true); }}, {deep: true});\r\n    return target;\r\n}\r\n\r\n//\r\nexport const derivate = (from, reactFn, watch?) => {\r\n    return bindWith(reactFn(safe(from)), from, watch);\r\n}\r\n\r\n//\r\nexport const subscribe = (target: any, cb: (value: any, prop: keyType) => void, ctx: any | null = null)=>{\r\n    const isPair = Array.isArray(target) && target?.length == 2 && [\"object\", \"function\"].indexOf(typeof target?.[0]) >= 0 && isKeyType(target?.[1]);\r\n    const prop = isPair ? target?.[1] : null;\r\n\r\n    // hard and advanced definition\r\n    target = (isPair && prop != null) ? (target?.[0] ?? target) : target;\r\n\r\n    //\r\n    (target = $originalObjects$.get(target) ?? target?.[$originalKey$] ?? target);\r\n    const unwrap: any = (typeof target == \"object\" || typeof target == \"function\") ? (target?.[$extractKey$] ?? target) : target;\r\n\r\n    //\r\n    if (prop != null) {\r\n        callByProp(unwrap, prop, cb, ctx);\r\n    } else {\r\n        callByAllProp(unwrap, cb, ctx);\r\n    }\r\n\r\n    //\r\n    const self = subscriptRegistry.get(unwrap);\r\n    self?.subscribe?.(cb, prop);\r\n    return self;\r\n}\r\n\r\n//\r\nexport class ReactiveMap {\r\n    //\r\n    constructor() {\r\n    }\r\n\r\n    //\r\n    has(target, prop: keyType) {\r\n        return Reflect.has(target, prop);\r\n    }\r\n\r\n    //\r\n    get(target, name: keyType, ctx) {\r\n        if (name == $extractKey$ || name == $originalKey$) {\r\n            return target?.[name] ?? target;\r\n        }\r\n\r\n        //\r\n        const valueOrFx = bindCtx(target, Reflect.get(target, name, ctx));\r\n\r\n        //\r\n        if (name == \"delete\") {\r\n            return (prop, _ = null) => {\r\n                const oldValue = target.get(prop);\r\n                const result = valueOrFx(prop);\r\n                subscriptRegistry.get(target)?.trigger?.(prop, null, oldValue);\r\n                return result;\r\n            };\r\n        }\r\n\r\n        //\r\n        if (name == \"set\") {\r\n            return (prop, value) => {\r\n                const oldValue = target.get(prop);\r\n                const result = valueOrFx(prop, value);\r\n                subscriptRegistry.get(target)?.trigger?.(prop, value, oldValue);\r\n                return result;\r\n            };\r\n        }\r\n\r\n        //\r\n        return valueOrFx;\r\n    }\r\n\r\n    //\r\n    construct(target, args, newT) {\r\n        return Reflect.construct(target, args, newT);\r\n    }\r\n\r\n    //\r\n    apply(target, ctx, args) {\r\n        return Reflect.apply(target, ctx, args);\r\n    }\r\n}\r\n\r\n//\r\nexport class ReactiveSet {\r\n    constructor() {\r\n    }\r\n\r\n    //\r\n    has(target, prop: keyType) {\r\n        return Reflect.has(target, prop);\r\n    }\r\n\r\n    //\r\n    get(target, name: keyType, ctx) {\r\n        //\r\n        if (name == $extractKey$) {\r\n            return target?.[$extractKey$] ?? target;\r\n        }\r\n\r\n        //\r\n        const valueOrFx = bindCtx(target, Reflect.get(target, name, ctx));\r\n\r\n        //\r\n        if (name == \"delete\") {\r\n            return (value) => {\r\n                const oldValue = target.has(value) ? value : null;\r\n                const result   = valueOrFx(value);\r\n                subscriptRegistry.get(target)?.trigger?.(value, null, oldValue);\r\n                return result;\r\n            };\r\n        }\r\n\r\n        //\r\n        if (name == \"add\") {\r\n            return (value) => {\r\n                const oldValue = target.has(value) ? value : null;\r\n                const result   = valueOrFx(value);\r\n                subscriptRegistry.get(target)?.trigger?.(value, value, oldValue);\r\n                return result;\r\n            };\r\n        }\r\n\r\n        //\r\n        return valueOrFx;\r\n    }\r\n\r\n    //\r\n    construct(target, args, newT) {\r\n        return Reflect.construct(target, args, newT);\r\n    }\r\n\r\n    //\r\n    apply(target, ctx, args) {\r\n        return Reflect.apply(target, ctx, args);\r\n    }\r\n}\r\n\r\n//\r\nexport class ReactiveObject {\r\n    constructor() {\r\n    }\r\n\r\n    //\r\n    get(target, name: keyType, ctx) {\r\n        if (name == $extractKey$) {\r\n            return target?.[$extractKey$] ?? target;\r\n        }\r\n        return bindCtx(target, Reflect.get(target, name, ctx));\r\n    }\r\n\r\n    //\r\n    construct(target, args, newT) {\r\n        return Reflect.construct(target, args, newT);\r\n    }\r\n\r\n    //\r\n    has(target, prop: keyType) {\r\n        return Reflect.has(target, prop);\r\n    }\r\n\r\n    //\r\n    apply(target, ctx, args) {\r\n        return Reflect.apply(target, ctx, args);\r\n    }\r\n\r\n    //\r\n    set(target, name: keyType, value) {\r\n        const oldValue = target[name];\r\n        const result = Reflect.set(target, name, value);\r\n        const self = subscriptRegistry.get(target);\r\n        self?.trigger?.(name, value, oldValue);\r\n        return result;\r\n    }\r\n\r\n    //\r\n    deleteProperty(target, name: keyType) {\r\n        const oldValue = target[name];\r\n        const result = Reflect.deleteProperty(target, name);\r\n        const self = subscriptRegistry.get(target);\r\n        self?.trigger?.(name, null, oldValue);\r\n        return result;\r\n    }\r\n}\r\n\r\n//\r\nexport const makeReactiveObject: <T extends object>(map: T) => T = <T extends object>(obj: T) => new Proxy<T>(obj?.[$extractKey$] ?? obj, register(obj, new ReactiveObject()) as ProxyHandler<T>);\r\nexport const makeReactiveMap: <K, V>(map: Map<K, V>) => Map<K, V> = <K, V>(map: Map<K, V>) => new Proxy(map?.[$extractKey$] ?? map, register(map, new ReactiveMap()) as ProxyHandler<Map<K, V>>);\r\nexport const makeReactiveSet: <V>(set: Set<V>) => Set<V> = <V>(set: Set<V>) => new Proxy(set?.[$extractKey$] ?? set, register(set, new ReactiveSet()) as ProxyHandler<Set<V>>);\r\n\r\n//\r\nexport const createReactiveMap: <K, V>(map?: [K, V][]) => Map<K, V> = <K, V>(map: [K, V][] = []) => new Proxy(new Map(map), register(map, new ReactiveMap()) as ProxyHandler<Map<K, V>>);\r\nexport const createReactiveSet: <V>(set?: V[]) => Set<V> = <V>(set: V[] = []) => new Proxy(new Set(set), register(set, new ReactiveSet()) as ProxyHandler<Set<V>>);\r\n\r\n//stateMap\r\nexport const makeReactive: any = (target: any, stateName = \"\"): any => {\r\n    const unwrap: any = (typeof target == \"object\" || typeof target == \"function\") ? (target?.[$extractKey$] ?? target) : target;\r\n    let reactive = target;\r\n\r\n    //\r\n    if (unwrap instanceof Map || unwrap instanceof WeakMap) {\r\n        reactive = makeReactiveMap(target);\r\n    } else\r\n\r\n    //\r\n    if (unwrap instanceof Set || unwrap instanceof WeakSet) {\r\n        reactive = makeReactiveSet(target);\r\n    } else\r\n\r\n    //\r\n    if (typeof unwrap == \"function\" || typeof unwrap == \"object\") {\r\n        reactive = makeReactiveObject(target);\r\n    }\r\n\r\n    //\r\n    //if (stateName) stateMap.set(stateName, reactive);\r\n\r\n    //\r\n    return reactive;\r\n}\r\n\r\n//\r\nexport const createReactive: any = (target: any, stateName = \"\"): any => {\r\n    const unwrap: any = (typeof target == \"object\" || typeof target == \"function\") ? (target?.[$extractKey$] ?? target) : target;\r\n    let reactive = target;\r\n\r\n    // BROKEN!\r\n    if (Array.isArray(target)) {\r\n        //reactive = createReactiveMap(target);\r\n        //reactive = createReactiveSet(target);\r\n    } else\r\n\r\n    //\r\n    if (typeof unwrap == \"function\" || typeof unwrap == \"object\") {\r\n        reactive = makeReactiveObject(target);\r\n    }\r\n\r\n    //\r\n    //if (stateName) stateMap.set(stateName, reactive);\r\n\r\n    //\r\n    return reactive;\r\n}\r\n","export const UUIDv4 = () => {\r\n    return (crypto?.randomUUID ? crypto?.randomUUID() : (\"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, c => (+c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (+c / 4)))).toString(16))));\r\n};\r\n\r\n//\r\nexport default class AxTime {\r\n    #lastTime = 0;\r\n    static looping = new Map<string, Function>([]);\r\n    static registry = new FinalizationRegistry(tmp => {\r\n        AxTime.looping.delete(tmp as string);\r\n    });\r\n\r\n    //\r\n    constructor() {\r\n        this.#lastTime = 0; //performance.now();\r\n    }\r\n\r\n    //\r\n    available(elapsed, fn = () => true) {\r\n        const now = performance.now();\r\n        if (now - this.#lastTime >= elapsed) {\r\n            if (fn()) {\r\n                this.#lastTime = now;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //\r\n    static symbol(name: string = \"\") {\r\n        const sym = Symbol(name || \"switch\");\r\n        document[sym] = true;\r\n        return sym;\r\n    }\r\n\r\n    //\r\n    static async rafLoop(fn, ctx = document) {\r\n        const tmp = UUIDv4(); // break GC holding loop\r\n        try {\r\n            AxTime.looping.set(tmp, fn);\r\n        } catch (e) {\r\n            console.warn(e);\r\n        }\r\n\r\n        if (ctx != null && (typeof ctx)) {\r\n            try {\r\n                AxTime?.registry?.register?.(ctx, tmp);\r\n            } catch (e) {\r\n                console.warn(e);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //\r\n    static get raf() {\r\n        return new Promise(r => requestIdleCallback(r));\r\n    }\r\n\r\n    // protect from looping (for example)\r\n    static protect(fn, interval = 100) {\r\n        const timer = new AxTime();\r\n        return timer.protect(fn, interval);\r\n    }\r\n\r\n    // protect from looping (for example)\r\n    static cached(fn, interval = 100) {\r\n        const timer = new AxTime();\r\n        return timer.cached(fn, interval);\r\n    }\r\n\r\n    //\r\n    cached(fn, interval = 100) {\r\n        let lastVal = null;\r\n        return (...args) => {\r\n            return (this.available(interval) || lastVal == null) ? (lastVal = fn(...args)) : lastVal;\r\n        };\r\n    }\r\n\r\n    //\r\n    protect(fn, interval = 100) {\r\n        return (...args) => {\r\n            return this.available(interval) ? fn(...args) : null;\r\n        };\r\n    }\r\n}\r\n\r\n//\r\nexport {AxTime as Time};\r\nexport const defaultTimer = new AxTime();\r\n\r\n//\r\nrequestIdleCallback(async () => {\r\n    while (true) {\r\n        await Promise.allSettled(Array.from(AxTime.looping.values()).map(fn => fn?.(performance.now())));\r\n        await new Promise(r => requestAnimationFrame(r));\r\n    }\r\n}, {timeout: 100});\r\n"],"names":["$extractKey$","$originalKey$","$originalObjects$","WeakMap","boundCtx","bindCtx","target","fx","has","set","be","get","bfx","bind","isIterable","obj","Symbol","iterator","callByProp","unwrap","prop","cb","ctx","Map","Set","WeakSet","Reflect","safe","mapped","e","Array","isArray","map","from","entries","K","V","values","Object","fromEntries","filter","removeExtra","value","name","exists","exEntries","keys","exe","exclude","difference","nw","_","I","splice","length","push","k","delete","mergeByKey","items","key","objectAssign","removeNotExists","mergeKey","E","mergeObj","find","add","assign","AssignObjectHandler","constructor","construct","args","newT","apply","deleteProperty","makeObjectAssignable","px","Proxy","Subscript","subscribers","listeners","this","subscribe","trigger","oldValue","forEach","subscriptRegistry","register","what","handle","bindByKey","reactive","id","bindWith","watch","v","p","N","deep","derivate","reactFn","isPair","indexOf","callByAllProp","self","ReactiveMap","valueOrFx","result","ReactiveSet","ReactiveObject","makeReactiveObject","makeReactiveMap","makeReactiveSet","createReactiveMap","createReactiveSet","makeReactive","stateName","createReactive","UUIDv4","crypto","randomUUID","replace","c","getRandomValues","Uint8Array","toString","AxTime","lastTime","static","FinalizationRegistry","tmp","looping","available","elapsed","fn","now","performance","sym","document","rafLoop","console","warn","registry","raf","Promise","r","requestIdleCallback","protect","interval","cached","lastVal","defaultTimer","allSettled","requestAnimationFrame","timeout"],"mappings":"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"}